'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report, datalist[[param]]$witness, datalist[[param]]$name, paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=6, align = 'hv')
return(plotgrid)
}
if (mode=='parm'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
weatherPlotGrid('temperature', mode='param')
# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param, mode){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report, datalist[[param]]$witness, datalist[[param]]$name, paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=6, align = 'hv')
return(plotgrid)
}
if (mode=='param'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
weatherPlotGrid('temperature', mode='param')
### Appel des librairies requises
require(RPostgreSQL)
require(tidyverse)
require(cowplot)
require(DT)
weatherPlotGrid('temperature', mode='param')
weatherPlotGrid('idf', mode='region')
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='landscape', extension='pdf')
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='portrait', extension='pdf')
## Defining plotsaving Function Template
plotsave <- function(plot, plotname, extension='png', format='landscape', plotpath=NULL){
if(format=='portrait'){
height=23.39# papier A3 (8.27 A4)
width=16.54
}else if (format=='landscape'){
width=16.54 # papier A3
height=11.69
}
ggsave2(filename = plotname,
plot = plot,
path = plotpath,
device= extension,
width=width, # format A4
height=height,
units = 'in',
# dpi = 92,
limitsize=TRUE)
}
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='portrait', extension='pdf')
## Defining plotsaving Function Template
plotsave <- function(plot, plotname, extension='png', format='landscape', plotpath=NULL){
if(format=='portrait'){
height=23.39# papier A3 (8.27 A4)
width=16.54
}else if (format=='landscape'){
width=23.39 # papier A3
height=16.54
}
ggsave2(filename = plotname,
plot = plot,
path = plotpath,
device= extension,
width=width, # format A4
height=height,
units = 'in',
# dpi = 92,
limitsize=TRUE)
}
# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param, mode){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report, datalist[[param]]$witness, datalist[[param]]$name, paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=6, nrow=2, align = 'hv')
return(plotgrid)
}
if (mode=='param'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='portrait', extension='pdf')
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='landscape', extension='pdf')
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='portrait', extension='pdf')
# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param, mode){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report, datalist[[param]]$witness, datalist[[param]]$name, paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=6, align = 'hv')
return(plotgrid)
}
if (mode=='param'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='portrait', extension='pdf')
f <- weatherPlotGrid('france', mode='region')
plotsave(g, 'france_plot_grid.pdf', format='portrait', extension='pdf')
plotsave(f, 'france_plot_grid.pdf', format='portrait', extension='pdf')
f <- weatherPlotGrid('france', mode='region')
plotsave(f, 'france_plot_grid.pdf', format='portrait', extension='png')
plotsave(f, 'france_plot_grid.png', format='portrait', extension='png')
plotsave(f, 'france_plot_grid.pdf', format='portrait', extension='pdf')
