# pour plus de détail consultez les références d'explication de la méthode additive
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)),
ceiling(max(humdata[,param], na.rm = T)),
by=4),
limits = c(floor( min(humdata[,param], na.rm = T)),
ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report,
datalist[[param]]$witness,
datalist[[param]]$name,
paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=6, align = 'hv')
return(plotgrid)
}
if (mode=='param'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
### Vecteur de caracteres contenant les parametres meteo a traiter
vectornames <- c("temperature",  "temperaturelow", "temperaturehigh", "humidity",
"dewpoint",   "pressure",      "windspeed",
"visibility", "cloudcover",   "windgust", "uvindex")
### Calcule et generation rapide et automatique des tables statistiques
## Periode annuelle sur la France entier ou les trois regions d’etude
# France entiere
france_quartile <- ic_table_maker(humdata, DSKdata, vectornames, calcul='quartile')
datatable(france_quartile)
#idf
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='decile')
datatable(idf_decile)
#alsace
alsace_decile <- ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile')
datatable(alsace_decile)
#rhone-alpes
rhone_alpes_decile <- ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
datatable(rhone_alpes_decile)
## Periode hivernale longue deciles
ic_hiver_long_decile <- ic_table_maker(humdata_winter_long,
DSKdata_winter_long,
vectornames,
calcul='decile')
datatable(ic_hiver_long_decile)
# Periode hivernale courte deciles
ic_hiver_short_decile <- ic_table_maker(humdata_winter_short,
DSKdata_winter_short,
vectornames,
calcul='decile')
datatable(ic_hiver_short_decile)
# Periode hivernale longue quartiles
ic_hiver_long_decile <- ic_table_maker(humdata_winter_long,
DSKdata_winter_long,
vectornames,
calcul='quartile')
datatable(ic_hiver_long_decile)
# Periode hivernale courte quartiles
ic_hiver_short_decile <- ic_table_maker(humdata_winter_short,
DSKdata_winter_short,
vectornames,
calcul='quartile')
datatable(ic_hiver_short_decile)
## Vecteurs de caracteres contenant les parametres meteo a comparer un a un
dsk_paramnames <- c("temperature", "temperaturelow", "temperaturehigh",
"humidity", "dewpoint", "pressure", "windspeed",
"visibility", "cloudcover", "windgust", 'precipintensity', 'uvindex')
mf_paramnames <- c('temperature', 'temperature_nocturne', 'temperature_diurne',
'humidite_floor', 'point_rose', 'press_mer', 'vvent',
'visibilite', 'nebulosite_floor','rafale_10min', 'precip_24h')
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames, mf_paramnames)
datatable(shapiro_df)
# Calcule de la table DSK vs MF au test t.test
m <- t.test_batch(dsk_paramnames, mf_paramnames)
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Wilcoxon
m <- kwcox_table(dsk_paramnames, mf_paramnames, test='wilcox')
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Kruskal-Wallis
m <- kwcox_table(dsk_paramnames, mf_paramnames, test='kruskal')
datatable(m)
g <- batch_histogram(DSKdata_42avg, MFdata, dsk_paramnames[-12], mf_paramnames)
# commande courte mais sans possibilite d’arrangement des positions
weather_gridplot_g <- plot_grid(plotlist=g, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_g <- paste('Average parameters for 42 Météo France Synoptic Stations vs DarkSky (France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
bkg <- ggplot()
title_g <- ggdraw(bkg) + draw_label(title_text_g, fontface='bold', size = 12, lineheight = 0.3)
# rel_heights values control title margins
weather_gridplot_g <- plot_grid(title_g, weather_gridplot_g, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_g, 'dsk_vs_mf_moyennes_france.png', format='landscape', extension='png')
### Fabrication rapide et automatique des graphiques human data vs DSK moyennes semi 700 pts
h <- batch_histogram(humdata, DSKdata_700avg, dsk_paramnames, dsk_paramnames)
weather_gridplot_h <- plot_grid(plotlist=h, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_h <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_h <- ggdraw(bkg) + draw_label(title_text_h, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_h <- plot_grid(title_h, weather_gridplot_h, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_h, 'humdata_vs_dsk_random700_france.png', format='landscape', extension='png')
### Gridplots regeionaux
# idf
idf <- batch_histogram(humdata_idf, DSKdata_700avg_idf, dsk_paramnames, dsk_paramnames)
weather_gridplot_idf <- plot_grid(plotlist=idf, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_idf <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (île-de-France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_idf <- ggdraw(bkg) + draw_label(title_text_idf, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_idf <- plot_grid(title_idf, weather_gridplot_idf, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_idf, 'humdata_vs_dsk_random700_idf.png', format='landscape', extension='png')
# alsace
al <- batch_histogram(humdata_al, DSKdata_700avg_al, dsk_paramnames, dsk_paramnames)
weather_gridplot_al <- plot_grid(plotlist=al, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_al <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (Alsace, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_al <- ggdraw(bkg) + draw_label(title_text_al, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_al <- plot_grid(title_al, weather_gridplot_al, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_al, 'humdata_vs_dsk_random700_al.png', format='landscape', extension='png')
#ra
ra <- batch_histogram(humdata_ra, DSKdata_700avg_ra, dsk_paramnames, dsk_paramnames)
weather_gridplot_ra <- plot_grid(plotlist=ra, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (Rhône-Alpes, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title <- ggdraw(bkg) + draw_label(title_text, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_ra <- plot_grid(title, weather_gridplot_ra, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_ra, 'humdata_vs_dsk_random700_ra.png', format='landscape', extension='png')
t <- weatherPlotGrid('temperature', mode='param')
plotsave(t, 'temperature_plot_grid.pdf', format='landscape', extension='pdf')
h <- weatherPlotGrid('humidity', mode='param')
plotsave(h, 'humidity_plot_grid.pdf', format='landscape', extension='pdf')
g <- weatherPlotGrid('idf', mode='region')
plotsave(g, 'idf_plot_grid.pdf', format='portrait', extension='pdf')
f <- weatherPlotGrid('france', mode='region')
plotsave(f, 'france_plot_grid.pdf', format='portrait', extension='pdf')
require(RSQLite)
require(piggyback)
require(tidyverse)
require(cowplot)
require(DT)
filter(humdata, department_code %in% c("54","55","57","88","67","68") )
View(humdata)
filter(humdata, departement_code %in% c("54","55","57","88","67","68") )
humdata_al_bis <- filter(humdata, departement_code %in% c("54","55","57","88","67","68") )
humdata_al_bis <- filter(humdata, departement_code == c("54","55","57","88","67","68") )
filter(humdata, date_piqure_saisie >= "2017-10-01" & date_piqure_saisie  <= "2018-03-31" )
humdata_idf <- filter(humdata, departement_code %in% c("75","77","78",91:95))
## 2.4.1 Création du subset pour l'IDF:
# signalements
humdata_idf <- humdata[humdata$departement_code %in% c("75","77","78",91:95),]
humdata_al <- filter(humdata, departement_code %in% c("54","55","57","88","67","68"))
DSKdata_al <- filter(DSKdata, departement_code %in% c("54","55","57","88","67","68") )
?paste
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 30), collapse = "\n") )
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 30), collapse = "\n") )
plot(dist ~ speed, cars, main = title)
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 90), collapse = "\n") )
plot(dist ~ speed, cars, main = title)
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 10), collapse = "\n") )
plot(dist ~ speed, cars, main = title)
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 20), collapse = "\n") )
plot(dist ~ speed, cars, main = title)
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 26), collapse = "\n") )
plot(dist ~ speed, cars, main = title)
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 26)) )
plot(dist ~ speed, cars, main = title)
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 26)) )
## Using paste() in combination with strwrap() can be useful
## for dealing with long strings.
(title <- paste(strwrap(
"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)",
width = 26)) )
hawaii
data(hawaii)
library(marmap)
library(marmap)
hawaii
hawaii
?data
data("hawaii")
require(tidyverse)
?autoplot
get('hawaii')
class('hawaii')
class(get('hawaii'))
hawaii <- get('hawaii')
class(hawaii)
autoplot(hawaii)
data("aleutians")
hawaii <- get('aleutians')
autoplot(hawaii)
weatherPlotGrid('temperature', mode='param')
#### 1. Mise en place de l’environnement de travail
setwd('./')
getwd()
### Appel des librairies requises
# le script ne se lancera pas correctement sans
# l’invocation prelalable de ces librairies
require(RSQLite)
require(piggyback)
require(tidyverse)
require(cowplot)
require(DT)
weatherPlotGrid('temperature', mode='param')
weatherPlotGrid('france', mode='region')
f <- weatherPlotGrid('france', mode='region')
plotsave(f, 'france_plot_grid.pdf', format='portrait', extension='pdf')
plotsave(f, 'france_plot_grid.svg', format='portrait', extension='svg')
## Defining plotsaving Function Template
plotsave <- function(plot, plotname, extension='png', format='landscape', plotpath=NULL){
if(format=='portrait'){
height=11.69  #(8.27/11.69 A4)
width=8.27
}else if (format=='landscape'){
width=23.39 # papier A3
height=16.54
}
ggsave2(filename = plotname,
plot = plot,
path = plotpath,
device= extension,
width=width, # format A4
height=height,
units = 'in',
# dpi = 92,
limitsize=TRUE)
}
plotsave(f, 'france_plot_grid.png', format='portrait', extension='png')
plotsave(f, 'france_plot_grid.svg', format='portrait', extension='svg')
# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param, mode){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée
# de signalements citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références d'explication de la méthode additive
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )),
colour='orange',
linetype='twodash',
alpha=.8,
size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')),
colour='grey50',
linetype='twodash',
alpha=.8,
size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')),
colour='grey50',
linetype='twodash',
alpha=.8,
size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')),
colour='orange',
linetype='twodash',
alpha=.8,
size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1))+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+
# Les elements de la legende en une seule rangee
guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)),
ceiling(max(humdata[,param], na.rm = T)),
by=4),
limits = c(floor( min(humdata[,param], na.rm = T)),
ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']]<-weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]<-weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]<-weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]<-weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report,
datalist[[param]]$witness,
datalist[[param]]$name,
paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=3, nrow=4, align = 'hv')
return(plotgrid)
}
if (mode=='param'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
f <- weatherPlotGrid('france', mode='region')
plotsave(f, 'france_plot_grid.pdf', format='portrait', extension='pdf')
weatherPlotGrid('france', mode='region')
datatable(france_quartile)
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='decile')
datatable(idf_decile)
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
datatable(shapiro_df)
#### 1. Mise en place de l’environnement de travail
setwd('./')
getwd()
### Appel des librairies requises
# le script ne se lancera pas correctement sans
# l’invocation prelalable de ces librairies
require(RSQLite)
require(piggyback)
require(tidyverse)
require(cowplot)
require(DT)
datatable(france_quartile)
datatable(m)
m <- t(m)
datatable(m)
# Calcule de la table DSK vs MF au test t.test
m <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
m <- t(m)
datatable(m)
# Calcule de la table DSK vs MF au test t.test
m <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
m <- t(m)
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Wilcoxon
m <- kwcox_table(dsk_paramnames[-12], mf_paramnames, test='wilcox')
m <- t(m)
datatable(m)
# Calcule de la table DSK vs MF au test t.test
m <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
m <- t(m)
datatable(m)
# Calcule de la table DSK vs MF au test t.test
m <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
m <- t(m)
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Wilcoxon
m <- kwcox_table(dsk_paramnames[-12], mf_paramnames, test='wilcox')
m <- t(m)
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Kruskal-Wallis
m <- kwcox_table(dsk_paramnames[-12], mf_paramnames, test='kruskal')
m <- t(m)
datatable(m)
# Calcule de la table DSK vs MF au test t.test
m <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
m <- t(m)
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Wilcoxon
m <- kwcox_table(dsk_paramnames[-12], mf_paramnames, test='wilcox')
m <- t(m)
datatable(m)
# Calcule de la table du test DSK vs MF pour le test de Kruskal-Wallis
m <- kwcox_table(dsk_paramnames[-12], mf_paramnames, test='kruskal')
m <- t(m)
datatable(m)
