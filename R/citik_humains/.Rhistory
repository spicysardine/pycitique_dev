# Calcule de la table DSK vs MF au test t.test
t <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
t <- t(t)
datatable(t)
datatable(w)
datatable(k)
t <- t(t)
datatable(t)
# Calcule de la table DSK vs MF au test t.test
t <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
datatable(t)
# Calcule de la table DSK vs MF au test t.test
t <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
datatable(t)
t <- t(t)
datatable(t)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
datatable(t)
# fonction de benchmark et calcul des duree de traitement
benchmark <- function (start, end){
duration = end-start
duration <- round(duration, 1)
unit <- units(duration)
cat('Le temps total est: ',duration, ' ', unit, '\n')
return(duration)
}
# fonction de benchmark et calcul des duree de traitement
benchmark <- function (start, end){
duration = end-start
duration <- round(duration, 1)
unit <- units(duration)
cat('Le temps ecoule est: ',duration, ' ', unit, '\n')
return(duration)
}
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
warnings()
?shapiro.test
invisible()
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
?capture.output
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
# fonction du comparatif du test shapiro dsk vs mf fabrication en lot
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
capture.output( shapiroDSK <- shapiro.test(paramDSK) )
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
capture.output( cat("Hi\n"), file='NUL')
capture.output( cat("Hi\n"))
# fonction du comparatif du test shapiro dsk vs mf fabrication en lot
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
capture.output( shapiroDSK <- shapiro.test(paramDSK), file = NULL )
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
shapiro.test(humdata)
shapiro.test(humdata$temperature)
# fonction de fabrication en masse des tables comparatives du t.test
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
t.test_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
t.test_List <- list()
t_matrix <- matrix(nrow=4,ncol = length(dsk_paramnames))
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
# cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
i=1
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
test_result <- t.test(DSKdata_42avg[,paramdsk], MFdata[,parammf])
# cat(param[1], '|------>', param[2],'\n')
test_result_vector <- c(test_result$statistic[[1]], test_result$p.value[[1]],
test_result$parameter[[1]], test_result$conf.int[[1]])
t_matrix[,i] <- round(test_result_vector, digits = 10)
i=i+1
}
t_table <- as.data.frame(t_matrix)
names(t_table) <- dsk_paramnames
rownames(t_table) <- c('t.test_vs_MF', 'p.value_vs_MF', 'ddl_vs_MF', 'IC_vs_MF')
return(t_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
# print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
shapiro.test(humdata$temperature)
DSKdata_42avg$temperature
shapiro.test(DSKdata_42avg$temperature)
capture.output(shapiro.test(DSKdata_42avg$temperature))
capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL)
capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL)
sink(shapiro.test(DSKdata_42avg$temperature), file = NULL)
capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL)
invisible(capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL))
shapiro(DSKdata_42avg$temperature, MFdata$temperature)
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
shapiro(DSKdata_42avg$temperature, MFdata$temperature)
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
listShapiro <- list()
listShapiro[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
listShapiro[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(listShapiro)
}
shapiro(DSKdata_42avg$temperature, MFdata$temperature)
# fonction du comparatif du test shapiro dsk vs mf fabrication en lot
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
listShapiro <- list()
listShapiro[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
listShapiro[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(listShapiro)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
# print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
datatable(shapiro_df)
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
datatable(shapiro_df)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
# fonction parametrique permettant de fabriquer les tables comparatives
# du test cible wilcoxon ou kruskal-wallis
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
kwcox_table <- function (dsk_paramnames, mf_paramnames, test='wilcox'){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
# matrice vide pour le stockage des resultats des calculs
kwcox_matrix <- matrix(nrow=2, ncol = length(dsk_paramnames))
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
# cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# i est l’indice matriciel permettant de remplir la matrice par colonne
i=1
# boucle de calcul iteratif des tests
cat("Fabrication des données pour les tests et remplissage de la matrice de calcul\n")
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
# Preparation de la donnee des tests
# cat("__ Fabrication des données pour le test KW __\n")
dskdf <- data.frame(param=DSKdata_42avg[,paramdsk], data_provider='dsk')
mfdf <- data.frame(param=MFdata[,parammf], data_provider='mf')
kwcoxdata <- rbind(dskdf,mfdf)
# cat("__ Objet de donnée pour KW Fabriqué__", paramdsk, "|------>", parammf, "__\n\n")
if(test=='wilcox'){
test_result <- wilcox.test(param ~ data_provider, data = kwcoxdata)
rnames <- c('wilcox_vs_MF', 'p.value_vs_MF')
} else if (test=='kruskal'){
test_result <- kruskal.test(param ~ data_provider, data = kwcoxdata)
rnames <- c('kruskal_vs_MF', 'p.value_vs_MF')
}else{
print('Aucun nom de test valide fourni. tapez wilcox ou kruskal.')
}
test_result_vector <- c(test_result$statistic[[1]],
test_result$p.value[[1]])
kwcox_matrix[,i] <- test_result_vector
i=i+1
}
kwcox_table <- as.data.frame(kwcox_matrix)
names(kwcox_table) <- dsk_paramnames
rownames(kwcox_table) <- rnames
return(kwcox_table)
}
start = Sys.time()
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
print('Début de fabrication des graphiques')
### Fabrication rapide et automatique des graphiques DSK moyennes vs MF moyennes
# ces lignes fabriquent automatiquement tous les graphs de l’article
# la fonction batch_histogram renvoi une liste contenant les graphs fabriques
g <- batch_histogram(DSKdata_42avg, MFdata, dsk_paramnames[-12], mf_paramnames)
# commande courte mais sans possibilite d’arrangement des positions
weather_gridplot_g <- plot_grid(plotlist=g, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_g <- paste('Average parameters for 42 Météo France Synoptic Stations vs DarkSky (France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
bkg <- ggplot()
title_g <- ggdraw(bkg) + draw_label(title_text_g, fontface='bold', size = 12, lineheight = 0.3)
# rel_heights values control title margins
weather_gridplot_g <- plot_grid(title_g, weather_gridplot_g, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_g, 'dsk_vs_mf_moyennes_france.png', format='landscape', extension='png')
### Fabrication rapide et automatique des graphiques human data vs DSK moyennes semi 700 pts
h <- batch_histogram(humdata, DSKdata_700avg, dsk_paramnames, dsk_paramnames)
weather_gridplot_h <- plot_grid(plotlist=h, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_h <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_h <- ggdraw(bkg) + draw_label(title_text_h, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_h <- plot_grid(title_h, weather_gridplot_h, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_h, 'humdata_vs_dsk_random700_france.png', format='landscape', extension='png')
### Gridplots regeionaux
# idf
idf <- batch_histogram(humdata_idf, DSKdata_700avg_idf, dsk_paramnames, dsk_paramnames)
weather_gridplot_idf <- plot_grid(plotlist=idf, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_idf <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (île-de-France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_idf <- ggdraw(bkg) + draw_label(title_text_idf, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_idf <- plot_grid(title_idf, weather_gridplot_idf, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_idf, 'humdata_vs_dsk_random700_idf.png', format='landscape', extension='png')
# alsace
al <- batch_histogram(humdata_al, DSKdata_700avg_al, dsk_paramnames, dsk_paramnames)
weather_gridplot_al <- plot_grid(plotlist=al, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_al <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (Alsace, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_al <- ggdraw(bkg) + draw_label(title_text_al, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_al <- plot_grid(title_al, weather_gridplot_al, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_al, 'humdata_vs_dsk_random700_al.png', format='landscape', extension='png')
#ra
ra <- batch_histogram(humdata_ra, DSKdata_700avg_ra, dsk_paramnames, dsk_paramnames)
weather_gridplot_ra <- plot_grid(plotlist=ra, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (Rhône-Alpes, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title <- ggdraw(bkg) + draw_label(title_text, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_ra <- plot_grid(title, weather_gridplot_ra, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_ra, 'humdata_vs_dsk_random700_ra.png', format='landscape', extension='png')
print('Début de fabrication des graphiques')
### Fabrication rapide et automatique des graphiques DSK moyennes vs MF moyennes
# ces lignes fabriquent automatiquement tous les graphs de l’article
# la fonction batch_histogram renvoi une liste contenant les graphs fabriques
g <- batch_histogram(DSKdata_42avg, MFdata, dsk_paramnames[-12], mf_paramnames)
# commande courte mais sans possibilite d’arrangement des positions
weather_gridplot_g <- plot_grid(plotlist=g, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_g <- paste('Average parameters for 42 Météo France Synoptic Stations vs DarkSky (France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
bkg <- ggplot()
title_g <- ggdraw(bkg) + draw_label(title_text_g, fontface='bold', size = 12, lineheight = 0.3)
# rel_heights values control title margins
weather_gridplot_g <- plot_grid(title_g, weather_gridplot_g, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_g, 'dsk_vs_mf_moyennes_france.png', format='landscape', extension='png')
### Fabrication rapide et automatique des graphiques human data vs DSK moyennes semi 700 pts
h <- batch_histogram(humdata, DSKdata_700avg, dsk_paramnames, dsk_paramnames)
weather_gridplot_h <- plot_grid(plotlist=h, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_h <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_h <- ggdraw(bkg) + draw_label(title_text_h, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_h <- plot_grid(title_h, weather_gridplot_h, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_h, 'humdata_vs_dsk_random700_france.png', format='landscape', extension='png')
### Gridplots regeionaux
# idf
idf <- batch_histogram(humdata_idf, DSKdata_700avg_idf, dsk_paramnames, dsk_paramnames)
weather_gridplot_idf <- plot_grid(plotlist=idf, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_idf <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (île-de-France, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_idf <- ggdraw(bkg) + draw_label(title_text_idf, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_idf <- plot_grid(title_idf, weather_gridplot_idf, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_idf, 'humdata_vs_dsk_random700_idf.png', format='landscape', extension='png')
# alsace
al <- batch_histogram(humdata_al, DSKdata_700avg_al, dsk_paramnames, dsk_paramnames)
weather_gridplot_al <- plot_grid(plotlist=al, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text_al <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (Alsace, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title_al <- ggdraw(bkg) + draw_label(title_text_al, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_al <- plot_grid(title_al, weather_gridplot_al, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_al, 'humdata_vs_dsk_random700_al.png', format='landscape', extension='png')
#ra
ra <- batch_histogram(humdata_ra, DSKdata_700avg_ra, dsk_paramnames, dsk_paramnames)
weather_gridplot_ra <- plot_grid(plotlist=ra, labels = "AUTO", ncol=3, nrow = 4 , align = 'hv')
title_text <- paste('Comparaison of average weather parameters on ',nrow(humdata),' tick reportings (Rhône-Alpes, january 2017 - april 2020), ',nrow(DSKdata_700avg),' days')
title <- ggdraw(bkg) + draw_label(title_text, fontface='bold', size = 12, lineheight = 0.3)
weather_gridplot_ra <- plot_grid(title, weather_gridplot_ra, ncol=1, rel_heights=c(.05, 1), align = 'hv')
plotsave(weather_gridplot_ra, 'humdata_vs_dsk_random700_ra.png', format='landscape', extension='png')
View(DSKdata)
View(DSKdata_42avg)
View(humdata)
require(RSQLite)
require(piggyback)
require(ggplot2)
require(cowplot)
require(DT)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
start = Sys.time()
#### 1. Mise en place de l’environnement de travail
setwd('./')
getwd()
### Appel des librairies requises
# le script ne se lancera pas correctement sans
# l’invocation prelalable de ces librairies
require(RSQLite)
require(piggyback)
require(ggplot2)
require(cowplot)
require(DT)
# Authentification avec le compte GitHub accueillant le projet.
# Cette ligne d’authentification est necessaire mais provisoir, le temps de basculer
# le projet en mode publique.
Sys.setenv(GITHUB_TOKEN="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")
datapath='../../data'
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
print('Génération des objets à partir de la base. Veuillez patienter ...')
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
detach("package:piggyback", unload = TRUE)
install.packages("piggyback", dependencies = FALSE)
library(piggyback)
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
# Authentification avec le compte GitHub accueillant le projet.
# Cette ligne d’authentification est necessaire mais provisoir, le temps de basculer
# le projet en mode publique.
Sys.setenv(GITHUB_TOKEN="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")
datapath='../../data'
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
warnings()
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
plotsave(f, 'france_plot_grid.pdf', format='landscape', extension='pdf')
plotsave(g, 'idf_plot_grid.pdf', format='landscape', extension='pdf')
## Defining plotsaving Function Template
plotsave <- function(plot, plotname, extension='png', format='landscape', plotpath=NULL){
if(format=='portrait'){
height=16.54  #(8.27/11.69 A4)
width=11.69
}else if (format=='landscape'){
width=16.54 # papier A3
height=11.69
}
ggsave2(filename = plotname,
plot = plot,
path = plotpath,
device= extension,
width=width, # format A4
height=height,
units = 'in',
# dpi = 92,
limitsize=TRUE)
}
plotsave(f, 'france_plot_grid.pdf', format='landscape', extension='pdf')
plotsave(g, 'idf_plot_grid.pdf', format='landscape', extension='pdf')
plotsave(h, 'humidity_plot_grid.pdf', format='landscape', extension='pdf')
plotsave(t, 'temperature_plot_grid.pdf', format='landscape', extension='pdf')
# Authentification avec le compte GitHub accueillant le projet.
# Cette ligne d’authentification est necessaire mais provisoir, le temps de basculer
# le projet en mode publique.
# Sys.setenv(GITHUB_TOKEN="token_here")
datapath='../../data/'
target='citique.zip'
pb_download(target, repo = 'spicysardine/pycitique', dest = datapath)
require(RSQLite)
require(piggyback)
require(ggplot2)
require(cowplot)
require(DT)
pb_download(target, repo = 'spicysardine/pycitique', dest = datapath)
### Appel des librairies requises
# le script ne se lancera pas correctement sans
# l’invocation prelalable de ces librairies
require(RSQLite)
require(piggyback)
require(ggplot2)
require(cowplot)
require(DT)
# Authentification avec le compte GitHub accueillant le projet.
# Cette ligne d’authentification est necessaire mais provisoir, le temps de basculer
# le projet en mode publique.
# Sys.setenv(GITHUB_TOKEN="token_here")
datapath='../../data/'
target='citique.zip'
require(utils)
# Authentification avec le compte GitHub accueillant le projet.
# Cette ligne d’authentification est necessaire mais provisoir, le temps de basculer
# le projet en mode publique.
# Sys.setenv(GITHUB_TOKEN="token_here")
datapath='../../data/'
target='citique.zip'
pb_download(target, repo = 'spicysardine/pycitique', dest = datapath)
target=paste0(datapath,target)
pb_download(target, repo = 'spicysardine/pycitique', dest = datapath)
