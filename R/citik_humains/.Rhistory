# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# export au format csv
date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
write.csv(ic_table, paste('ic', calcul, date,'.csv', sep = '_') )
}
ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
write.csv(ic_table, paste('ic', calcul, date,'.csv', sep = '_') )
write.csv(ic_table, paste('ic', 'calcul', date,'.csv', sep = '_') )
write.csv(ic_table, filename )
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# export au format csv
date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
filename <- paste('ic', calcul, date,'.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='decile')
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# export au format csv
date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
filename <- paste('ic', calcul, date,'.csv', sep = '_')
write.csv(ic_table, 'filename.csv' )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# export au format csv
date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
filename <- paste('ic', calcul, date,'.csv', sep = '_')
write.csv(ic_table, 'filename.csv' )
}
ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
options(digits = 2)
}
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# # export au format csv
# date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
# filename <- paste('ic', calcul, date,'.csv', sep = '_')
write.csv(ic_table, 'filename.csv' )
}
ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# # export au format csv
# date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
filename <- paste('ic', calcul, '.csv', sep = '_')
write.csv(ic_table, 'filename.csv' )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
write.csv(ic_table, filename )
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# # export au format csv
# date <- format(Sys.time(), "%A %b %d %Hh%Mm%Ss %Y")
filename <- paste('ic', calcul, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# # export au format csv
date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
filename <- paste('ic', calcul, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
View(ic_table)
# # export au format csv
date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
filename <- paste('ic', calcul, date, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quartile')
require(DT)
ic_calculator <- function(param, calcul){
## création d'une table 1000x3 index vides
## pour initialiser les dimensions et la valeurs des cellules du dataframe qui suit
## création d'un DF initialisé avec les valeurs de c1 pour les cellules et le nombre de lignes.
humDF <- data.frame("lower_quantile"=c(0:999),"middl_quantile"=c(0:999),"upper_quantile"=c(0:999))*NA
## boucle qui calcule 1000 fois sur un échantillon de 50 tirages les centiles 25, 50 et 75 à partir du vecteur index (cf. infra)
## /!\ il faut exclure les NA du calcul de la moyenne également /!\
## /!\ j'ai renommé le centile_3 en centile_75 /!\
if(calcul=='quartile'){
for (i in 1:1000){
humDF$lower_quantile[i] <- quantile(sample(param,50,replace=T), 0.25, na.rm = T);
humDF$middl_quantile[i] <- quantile(sample(param,50,replace=T), 0.50, na.rm = T);
humDF$upper_quantile[i] <- quantile(sample(param,50,replace=T), 0.75, na.rm = T);
}
}else if (calcul=='decile'){
for (i in 1:1000){
humDF$lower_quantile[i]    <- quantile(sample(param,50,replace=T),0.1, na.rm = T);
humDF$middl_quantile[i]    <- mean(sample(param,50,replace=T), na.rm = T);
humDF$upper_quantile[i]    <- quantile(sample(param,50,replace=T),0.9, na.rm = T);
}
} else{
print('Aucune opération valide demandée')
}
moy_quart1 <- mean(humDF$lower_quantile) ## moyenne des 1000 1er quantiles
moy_quart2 <- mean(humDF$middl_quantile) ## moyenne des 1000 2eme quantiles
moy_quart3 <- mean(humDF$upper_quantile) ## moyenne des 1000 3eme quantiles
humDF_C25.sort=sort(humDF$lower_quantile)
humDF_C50.sort=sort(humDF$middl_quantile)
humDF_C75.sort=sort(humDF$upper_quantile)
length_C25.sort <- length(na.omit(humDF_C25.sort))
length_C50.sort <- length(na.omit(humDF_C50.sort))
length_C75.sort <- length(na.omit(humDF_C75.sort))
## c(humDF_C25.sort[25], humDF_C25.sort[975])
quart1_IC_bas <- humDF_C25.sort[25]
quart1_IC_haut <- humDF_C25.sort[975]
## c(humDF_C50.sort[25], humDF_C50.sort[975])
quart2_IC_bas <- humDF_C50.sort[25]
quart2_IC_haut <- humDF_C50.sort[975]
## c(humDF_C75.sort[25], humDF_C75.sort[975])
quart3_IC_bas <- humDF_C75.sort[25]
quart3_IC_haut <- humDF_C75.sort[975]
# La fonction retourne ce vecteur numeric contenant les
# trois moyennes et leur intervale de confiance
output_Fr = c(moy_quart1, quart1_IC_bas, quart1_IC_haut,
moy_quart2, quart2_IC_bas, quart2_IC_haut,
moy_quart3, quart3_IC_bas, quart3_IC_haut)
return(output_Fr)
}
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
datatable(ic_table)
# # export au format csv
date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
filename <- paste('ic', calcul, date, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata, DSKdata, vectornames, calcul='decile' )
datatable(ic_table)
ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
datatable(ic_table)
# # export au format csv
date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
filename <- paste('ic', calcul, date, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
# datatable(ic_table)
# # export au format csv
date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
filename <- paste('ic', calcul, date, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quartile')
ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
options(digits = 2)
ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
vect <-  c(44.423423, 234,2344234)
round(vect,2)
vect <-  c(44.423423, 234.2344234)
round(vect,2)
?round
round(vect, digits=2)
vect <-  c(44.423423, 234.2344234)
round(vect, digits=2)
round(234.234, digits = 2)
trunc(234.234, digits = 2)
round(2119.1921, digits = 3)
