graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.5,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 8)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
weatherPlotGrid('temperature')
# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.5,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
weatherPlotGrid('temperature')
# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée de signalements
# citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références que je vous avais envoyés dans les mails précédents
# a utrement l'explication de la méthode additive est en dehors du sujet de l'article
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )), colour='orange', linetype='twodash', alpha=.8, size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')), colour='grey50', linetype='twodash', alpha=.8, size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')), colour='orange', linetype='twodash', alpha=.8, size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1) )+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)), by=4),
limits = c(floor( min(humdata[,param], na.rm = T)), ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
graphlist[['france']] <- weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]    <- weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]     <- weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]     <- weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
weatherPlotGrid('temperature')
## Defining plotsaving Function Template
plotsave <- function(plot, plotname, extension='png', format='landscape', plotpath=NULL){
if(format=='portrait'){
height=11.69# papier A4
width=8.27
}else if (format=='landscape'){
width=16.54 # papier A3
height=11.69
}
ggsave2(filename = plotname,
plot = plot,
path = plotpath,
device= extension,
width=width, # format A4
height=height,
units = 'in',
# dpi = 92,
limitsize=TRUE)
}
t <- weatherPlotGrid('temperature')
plotsave(t, 'temperature_plot_grid.pdf', format='landscape', extension='pdf')
## Defining plotsaving Function Template
plotsave <- function(plot, plotname, extension='png', format='landscape', plotpath=NULL){
if(format=='portrait'){
height=16.54# papier A4
width=11.69
}else if (format=='landscape'){
width=16.54 # papier A3
height=11.69
}
ggsave2(filename = plotname,
plot = plot,
path = plotpath,
device= extension,
width=width, # format A4
height=height,
units = 'in',
# dpi = 92,
limitsize=TRUE)
}
?plot_save
?save_plot
save_plot(t, 'Rplot')
save_plot('Rplot',t)
save_plot('Rplot.png',t)
knit_with_parameters("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/temp.Rmd")
View(midwest)
search()
### Appel des librairies requises
require(RPostgreSQL)
require(tidyverse)
require(cowplot)
require(DT)
search()
search(package=methods)
ls(package=methods)
ls("package:methods")
head(ls("package:methods"), 10)
head(ls("package:methods"), 20)
environment(methods)
env <- function(pkg){
environment(pkg)
}
pkglst <- list(read.tablem data, matrix, jpeg)
pkglst <- list(read.tablem, data, matrix, jpeg)
pkglst <- list(read.table, data, matrix, jpeg)
for(pkg in pkglst){
environment(pkg)
}
for(pkg in pkglst){
env(pkg)
}
env(jpeg)
for(pkg in pkglst){
env(pkg)
}
for(pkg in pkglst){
print(env(pkg))
}
pkgstring <- ls("package:smoothScatter")
pkgstring <- ls("package:smoothScatter")
pkgstring <- ls("package:ggplot2")
pkgstring <- ls("package:smoothScatter")
pkgstring <- ls("package:graphics")
pkgstring <- ls("package:graphics")
for(string in pkgstring){
if(string == smoothScatter){
print("the function smoothScatter is in the package graphics")
}
}
typeof(pkgstring)
pkgstring
for(string in pkgstring){
if(string == 'smoothScatter'){
print("the function smoothScatter is in the package graphics")
}
}
args(plot.default)
for (col in iris){
summary(iris)
}
for (col in iris){
s <- summary(iris)
print(s)
}
for (col in iris){
s <- summary(iris)
print('----\n')
print(s)
}
for (col in iris){
s <- summary(iris)
cat('----\n')
print(s)
}
for (col in iris){
boxplot(col)
cat('----\n')
print(s)
}
for (col in iris){
ggplot(iris, aes(iris[, colnames(col)]))+
geom_boxplot()
cat('----\n')
print(s)
}
for (col in iris){
p <- ggplot(iris, aes(iris[, colnames(col)]))+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in iris){
p <- ggplot(iris, aes(iris[, names(col)]) )+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in iris[,1:3]){
p <- ggplot(iris, aes(iris[, names(col)]) )+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in iris[,1:3]){
p <- ggplot(iris, aes(iris[, names(col)]) )+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in iris[,1:3]){
p <- ggplot(iris, aes(y=iris[, names(col)]) )+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(y=iris[, col]) )+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(y=iris[, col]) )+
geom_boxplot()
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(y=iris[, col]) )+
geom_histogram()
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col]) )+
geom_histogram()
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], colour=Species) )+
geom_histogram()
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], colour=Species) )+
geom_histogram(alpha=.7)
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], colour=Species) )+
geom_density(alpha=.7)
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], fill=Species) )+
geom_density(alpha=.7)
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], fill=Species) )+
geom_density(alpha=.7)+
xlab(names(iris[, col]))
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], fill=Species) )+
geom_density(alpha=.7)+
xlab(colnames(iris[, col]))
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], fill=Species) )+
geom_density(alpha=.7)+
ylab(colnames(iris[, col]))
cat('----\n')
print(p)
}
for (col in colnames(iris[,1:3])){
p <- ggplot(iris, aes(x=iris[, col], fill=Species) )+
geom_density(alpha=.7)+
xlab(colnames(iris[, col]))
cat('----\n')
print(p)
}
colnames(iris[, 1])
names(iris[, 1])
View(iris)
iris[, 1]
names(iris[, 'Sepal.Length'])
names(iris[, 'Sepal.Length'])
names(iris)
names(iris)
rm(DSKdata)
