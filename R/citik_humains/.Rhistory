# Fonction de fabrication des grilles des series temporelles
# elle recupere une chaine de caracteres du parmetre a analyser
# et retourne un objet de type liste contenant les graphiques
# des analyse. Le resultat peut etre ensuite utilise avec
# une librairie d’aggregation de graphiaues comme cowplot
weatherPlotGrid <- function(param, mode){
paramlist <- list("temperature"='Temperature (°C)',
"temperaturehigh"='Day temperature (°C)',
"temperaturelow"='Night temperature',
'humidity'='Humidity (%)',
"dewpoint"='Dewpoint (°C)',
"pressure"='Atmospheric Pressure (hPa)',
"windspeed"='Windspeed (m/s)',
"visibility"='Visibility (km)',
"cloudcover"='Cloud cover (%)',
'precipintensity'='Precipitation Intensity mm/h',
"windgust"='Wind Gust (m/s)',
'uvindex'='UV Index (scale 1 to 10)')
datalist <- list('france'=list('name'='France', 'report'=humdata, 'witness'=DSKdata_700avg ),
'idf'=list('name'='île-de-France', 'report'=humdata_idf, 'witness'=DSKdata_700avg_idf ),
'al'=list('name'='Alsace', 'report'=humdata_al,'witness'=DSKdata_700avg_al ),
'ra'=list('name'='Rhône-Alpes', 'report'=humdata_ra, 'witness'=DSKdata_700avg_ra )
)
graphlist <- list()
weatherPlot <- function(reportdata, witnessdata, region, param){
paramname <- paramlist[[param]]
## General theme
legende <- c('Reports'='#0000ff',
'Reports Model'='#000000',
'Random Witness'='#00ff00',
'Random Witness Model'='#ff0000',
'Equinox'='orange',
'Solstice'='grey50')
# Explication détaillée du graphique
# la date de la piqûre est en abscisse
# la donnée principale est tirée du dataframe humdata qui représente la table de donnée
# de signalements citik_humains_clean_weather_strict.csv
# dans mes script je travaille directememnt sur la base de donnée géographique postgis
# la donnée météo témoin DSKdata_700avg provient de la table darksky_maille_700_avg
# le grahique est établi à partir de la colonne temperature représentat
# la température moyenne obtenue en moyennant temphigh et templow
ggplot(reportdata, aes(x=date_piqure_saisie))+
# c'est la ligne qui affiche les poctuels des signalements
geom_jitter(aes(y=reportdata[,param], color='Reports'), size=.1, alpha=.6)+
# Cette ligne établit la courbe lisse noire des poinctuels
# par défaut elle utilise la méthode GAM ou general additive method si le nombre de points est
# supérieur à 1000, en utilisant en arrière plan la méthode method="gam", formula = y ~ s(x)
# comme paramètre, donc la fonction s(x) du packet R mgcv
# pour plus de détail consultez les références d'explication de la méthode additive
geom_smooth(aes(y=reportdata[,param], color='Reports Model'), size=.5)+
#cette lingne de code établit la ligne verte de la température témoin
geom_line(data = witnessdata,
aes(date_releve, witnessdata[,param], color='Random Witness'),
size=.4,
alpha=.7)+
#Meme chose que ci-dessus mais courebe lisse rouge de la donnée météo, donc température témoin
geom_smooth(data=witnessdata, aes(date_releve, witnessdata[,param], color='Random Witness Model'), size=.3)+
geom_line(y=0, colour='black', linetype='dotted', alpha=.7, size=.5)+
# equinox du printemps
geom_vline(xintercept=as.Date(c( '2017-03-21', '2018-03-21', '2019-03-21','2020-03-21' )),
colour='orange',
linetype='twodash',
alpha=.8,
size=.5)+
# solstice d’hiver
geom_vline(xintercept=as.Date(c( '2017-12-21', '2018-12-21', '2019-12-21')),
colour='grey50',
linetype='twodash',
alpha=.8,
size=.5)+
# solstice d’ete
geom_vline(xintercept=as.Date(c( '2017-06-21', '2018-06-21', '2019-06-21')),
colour='grey50',
linetype='twodash',
alpha=.8,
size=.5)+
#e quinox d’automne
geom_vline(xintercept=as.Date(c( '2017-09-21', '2018-09-21', '2019-09-21')),
colour='orange',
linetype='twodash',
alpha=.8,
size=.5)+
#titre du graph
ggtitle(paste('Seasonal distribution of ',paramname,' associated with reports vs witnesses
measurements in ',region,' from 2017-03-31 to 2020-04-01'))+
xlab(label = 'Date')+
ylab(label=paramname)+
labs(color='Legend: ')+
# les thèmes et labels des axes
theme(axis.text.x = element_text(angle = 35, color='grey20', size = 9, vjust = 1, hjust = 1))+
# theme(axis.text.y = element_text(color='grey20', size = 6) )+
theme(legend.position = 'top', legend.text = (element_text(size = 9)))+
# Les elements de la legende en une seule rangee
guides(col=guide_legend(nrow = 1))+
#Cette ligne est facultative, elle sert uniquement au cas où on a besoin
#de zoom sur une période de l'année ou pour restreindre le champ temporel
scale_y_continuous( breaks = seq(floor(min(humdata[,param], na.rm = T)),
ceiling(max(humdata[,param], na.rm = T)),
by=4),
limits = c(floor( min(humdata[,param], na.rm = T)),
ceiling(max(humdata[,param], na.rm = T)) ) )+
scale_x_date( expand = c(0,0),
limits=as.Date( c('2017-03-31','2020-04-01')),
date_labels = '%b %Y',
date_breaks = '2 month')+
scale_color_manual(values=legende)+plotstyle
}
getGrid_by_param <- function(param){
graphlist[['france']]<-weatherPlot(datalist$france$report, datalist$france$witness, datalist$france$name, param)
graphlist[['idf']]<-weatherPlot(datalist$idf$report, datalist$idf$witness, datalist$idf$name, param)
graphlist[['al']]<-weatherPlot(datalist$al$report, datalist$al$witness, datalist$al$name, param)
graphlist[['ra']]<-weatherPlot(datalist$ra$report, datalist$ra$witness, datalist$ra$name, param)
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=2, nrow=2, align = 'hv')
return(plotgrid)
}
getGrid_by_region <- function(param){
for (paramname in names(paramlist)){
graphlist[[paramname]] <- weatherPlot(datalist[[param]]$report,
datalist[[param]]$witness,
datalist[[param]]$name,
paramname)
}
# Cette fonction retourne un objet de type liste contenant
# les graphiques generes contenant les analyse. Le resultat peut
# etre ensuite aggrege avec une librairie d’aggregation de graphiaues comme cowplot
plotgrid <- plot_grid(plotlist=graphlist, labels = 'AUTO', ncol=3, nrow=4, align = 'hv')
return(plotgrid)
}
if (mode=='param'){
plotgrid <- getGrid_by_param(param)
return(plotgrid)
}else if (mode=='region'){
plotgrid <- getGrid_by_region(param)
return(plotgrid)
}else {
stop('Aucun mode de mosaicage fourni: france, idf, al, ra')
}
}
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
pb_download('citique.db', repo = 'spicysardine/pycitique', dest = datapath)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
## Code Figure n°6 – Profils temporels des variables météorologiques associés aux 14 657 lieux
## et dates de signalements comparés à ceux des mêmes dates, mais pour un semis de lieux aléatoires
## (France, April 1st 2017 – April 5th 2020, soit 1100 jours).
##
## Code Figure n°7 – Profils météorologiques associés aux 14 657 lieux et dates de signalements
## comparés à ceux des mêmes dates, mais pour un semis de lieux aléatoires
## (France, July 15th 2017 – April 5th 2020, soit 995 jours).
##
##
####################################################################################################
Sys.time()
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
temps_prep
temps_total
temps_prep = fin_prep-debut
temps_prep
temps_total = fin-debut
temps_total
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
typeof(fin_prep)
typeof(temps_prep)
fin_prep
debut
as.numeric(temps_prep)
temps_prep <- as.numeric(temps_prep)
print(temps_prep)
temps_total = fin-debut
temps_total <- as.numeric(temps_total)
print(temps_total)
temps_total <- roune(as.numeric(temps_total), 1)
temps_total <- round(as.numeric(temps_total), 1)
print(temps_total)
temps_prep <- round(as.numeric(temps_prep), 1)
# temps_prep <- round(as.numeric(temps_prep), 1)
print(temps_prep)
# temps_prep <- round(as.numeric(temps_prep), 1)
print('Le temps de preparation est: ',temps_prep)
temps_total = fin-debut
# temps_total <- round(as.numeric(temps_total), 1)
print('Le temps totoal est: ',temps_total)
# temps_total <- round(as.numeric(temps_total), 1)
print('Le temps totoal est: 'temps_total)
?print
# temps_prep <- round(as.numeric(temps_prep), 1)
cat('Le temps de preparation est: ',temps_prep)
# temps_total <- round(as.numeric(temps_total), 1)
cat('Le temps totoal est: ',temps_total)
temps_prep = fin_prep-debut
# temps_prep <- round(as.numeric(temps_prep), 1)
cat('Le temps de preparation est: ',temps_prep)
temps_prep
# temps_total <- round(as.numeric(temps_total), 1)
cat('Le temps total est: ',temps_total)
temps_total
units(temps_total)
# temps_total <- round(as.numeric(temps_total), 1)
cat('Le temps total est: ',temps_total, ' ', units(temps_total))
# temps_prep <- round(as.numeric(temps_prep), 1)
cat('Le temps de preparation est: ',temps_prep, ' ', units(temps_prep))
temps_prep = fin_prep-debut
temps_prep <- round(as.numeric(temps_prep), 1)
cat('Le temps de preparation est: ',temps_prep, ' ', units(temps_prep))
temps_prep = fin_prep-debut
temps_prep_rnd <- round(as.numeric(temps_prep), 1)
cat('Le temps de preparation est: ',temps_prep_rnd, ' ', units(temps_prep))
temps_prep = fin_prep-debut
temps_prep <- round(temps_prep, 1)
cat('Le temps de preparation est: ',temps_prep, ' ', units(temps_prep))
temps_total = fin-debut
temps_total <- round(temps_total, 1)
cat('Le temps total est: ',temps_total, ' ', units(temps_total))
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
print('Fin du programme')
# Partie benchmrque et temps d’execution
fin = Sys.time()
temps_prep = fin_prep-debut
temps_prep <- round(temps_prep, 1)
cat('Le temps de preparation est: ',temps_prep, ' ', units(temps_prep))
temps_total = fin-debut
temps_total <- round(temps_total, 1)
cat('Le temps total est: ',temps_total, ' ', units(temps_total))
print('Fin du programme')
# Partie benchmrque et temps d’execution
fin = Sys.time()
temps_prep = fin_prep-debut
temps_prep <- round(temps_prep, 1)
cat('Le temps de preparation est: ',temps_prep, ' ', units(temps_prep), '\n')
temps_total = fin-debut
temps_total <- round(temps_total, 1)
cat('Le temps total est: ',temps_total, ' ', units(temps_total), '\n')
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
datatable(shapiro_df)
datatable(t)
datatable(t)
# Calcule de la table DSK vs MF au test t.test
t <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
t <- t(t)
datatable(t)
datatable(w)
datatable(k)
t <- t(t)
datatable(t)
# Calcule de la table DSK vs MF au test t.test
t <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
datatable(t)
# Calcule de la table DSK vs MF au test t.test
t <- t.test_batch(dsk_paramnames[-12], mf_paramnames)
datatable(t)
t <- t(t)
datatable(t)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
datatable(t)
# fonction de benchmark et calcul des duree de traitement
benchmark <- function (start, end){
duration = end-start
duration <- round(duration, 1)
unit <- units(duration)
cat('Le temps total est: ',duration, ' ', unit, '\n')
return(duration)
}
# fonction de benchmark et calcul des duree de traitement
benchmark <- function (start, end){
duration = end-start
duration <- round(duration, 1)
unit <- units(duration)
cat('Le temps ecoule est: ',duration, ' ', unit, '\n')
return(duration)
}
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
warnings()
?shapiro.test
invisible()
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_analyse_statisitique.R")
?capture.output
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
# fonction du comparatif du test shapiro dsk vs mf fabrication en lot
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
capture.output( shapiroDSK <- shapiro.test(paramDSK) )
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
capture.output( cat("Hi\n"), file='NUL')
capture.output( cat("Hi\n"))
# fonction du comparatif du test shapiro dsk vs mf fabrication en lot
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
capture.output( shapiroDSK <- shapiro.test(paramDSK), file = NULL )
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
shapiro.test(humdata)
shapiro.test(humdata$temperature)
# fonction de fabrication en masse des tables comparatives du t.test
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
t.test_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
t.test_List <- list()
t_matrix <- matrix(nrow=4,ncol = length(dsk_paramnames))
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
# cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
i=1
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
test_result <- t.test(DSKdata_42avg[,paramdsk], MFdata[,parammf])
# cat(param[1], '|------>', param[2],'\n')
test_result_vector <- c(test_result$statistic[[1]], test_result$p.value[[1]],
test_result$parameter[[1]], test_result$conf.int[[1]])
t_matrix[,i] <- round(test_result_vector, digits = 10)
i=i+1
}
t_table <- as.data.frame(t_matrix)
names(t_table) <- dsk_paramnames
rownames(t_table) <- c('t.test_vs_MF', 'p.value_vs_MF', 'ddl_vs_MF', 'IC_vs_MF')
return(t_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
# print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
shapiro.test(humdata$temperature)
DSKdata_42avg$temperature
shapiro.test(DSKdata_42avg$temperature)
capture.output(shapiro.test(DSKdata_42avg$temperature))
capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL)
capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL)
sink(shapiro.test(DSKdata_42avg$temperature), file = NULL)
capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL)
invisible(capture.output(shapiro.test(DSKdata_42avg$temperature), file = NULL))
shapiro(DSKdata_42avg$temperature, MFdata$temperature)
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
shapiroList <- list()
shapiroList[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
shapiroList[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(shapiroList)
}
shapiro(DSKdata_42avg$temperature, MFdata$temperature)
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
listShapiro <- list()
listShapiro[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
listShapiro[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(listShapiro)
}
shapiro(DSKdata_42avg$temperature, MFdata$temperature)
# fonction du comparatif du test shapiro dsk vs mf fabrication en lot
# Cette fonction retourne un objet de type dataframe contenant les analyses croisees
shapiro_batch <- function (dsk_paramnames, mf_paramnames){
# Liste vide pour accueillir les nom de parametres
paramlist <- list()
shapiroList <- list()
# fonction du comparatif du test shapiro dsk vs mf
shapiro <- function(paramDSK, paramMF){
# La fonction R invisible() supprime la sortie en console, Inutile
# puisque le resultat est disponible dans le tableau des resulats
shapiroDSK <- shapiro.test(paramDSK)
shapiroMF <- shapiro.test(paramMF)
listShapiro <- list()
listShapiro[['shapiroDSK']] <- c('shapiro_test'=shapiroDSK$statistic[[1]],
'p.value'=shapiroDSK$p.value[[1]] )
listShapiro[['shapiroMF']] <- c('shapiro_test'=shapiroMF$statistic[[1]],
'p.value'=shapiroMF$p.value[[1]] )
return(listShapiro)
}
# boucle de remplissage de la liste de correspondance
for (i in 1:11){
#cat(dsk_paramnames[i], '|------>', mf_paramnames[i],'\n')
paramlist[[ dsk_paramnames[i] ]] <- c(dsk_paramnames[i], mf_paramnames[i])
}
# boucle de calcul
for (param in paramlist ){
paramdsk <- param[1]
parammf <- param[2]
result <- shapiro(DSKdata_42avg[,paramdsk], MFdata[,parammf])
# print(result)
shapiroList[[paramdsk]] <- c(result$shapiroDSK['shapiro_test'], result$shapiroDSK['p.value'])
shapiroList[[parammf]] <- c(result$shapiroMF['shapiro_test'], result$shapiroMF['p.value'])
}
shapiro_table <- as.data.frame(shapiroList)
shapiro_table <- t(shapiro_table)
return(shapiro_table)
}
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
datatable(shapiro_df)
# Ces lignes calculent puis affichent le tableau des tests de Shapiro de normalite
shapiro_df <- shapiro_batch(dsk_paramnames[-12], mf_paramnames)
datatable(shapiro_df)
