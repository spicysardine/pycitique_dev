for (i in 1:1000){
humDF$lower_quantile[i] <- quantile(sample(param,50,replace=T), 0.25, na.rm = T);
humDF$middl_quantile[i] <- quantile(sample(param,50,replace=T), 0.50, na.rm = T);
humDF$upper_quantile[i] <- quantile(sample(param,50,replace=T), 0.75, na.rm = T);
}
}else if (calcul=='decile'){
for (i in 1:1000){
humDF$lower_quantile[i]    <- quantile(sample(param,50,replace=T),0.1, na.rm = T);
humDF$middl_quantile[i]    <- mean(sample(param,50,replace=T), na.rm = T);
humDF$upper_quantile[i]    <- quantile(sample(param,50,replace=T),0.9, na.rm = T);
}
} else{
print('Aucune opération valide demandée')
}
moy_quart1 <- mean(humDF$lower_quantile) ## moyenne des 1000 1er quantiles
moy_quart2 <- mean(humDF$middl_quantile) ## moyenne des 1000 2eme quantiles
moy_quart3 <- mean(humDF$upper_quantile) ## moyenne des 1000 3eme quantiles
humDF_C25.sort=sort(humDF$lower_quantile)
humDF_C50.sort=sort(humDF$middl_quantile)
humDF_C75.sort=sort(humDF$upper_quantile)
length_C25.sort <- length(na.omit(humDF_C25.sort))
length_C50.sort <- length(na.omit(humDF_C50.sort))
length_C75.sort <- length(na.omit(humDF_C75.sort))
## c(humDF_C25.sort[25], humDF_C25.sort[975])
quart1_IC_bas <- humDF_C25.sort[25]
quart1_IC_haut <- humDF_C25.sort[975]
## c(humDF_C50.sort[25], humDF_C50.sort[975])
quart2_IC_bas <- humDF_C50.sort[25]
quart2_IC_haut <- humDF_C50.sort[975]
## c(humDF_C75.sort[25], humDF_C75.sort[975])
quart3_IC_bas <- humDF_C75.sort[25]
quart3_IC_haut <- humDF_C75.sort[975]
# La fonction retourne ce vecteur numeric contenant les
# trois moyennes et leur intervale de confiance
ic_vector = c(moy_quant1, quant1_IC_bas, quant1_IC_haut,
moy_quant2, quant2_IC_bas, quant2_IC_haut,
moy_quant3, quant3_IC_bas, quant3_IC_haut)
# arrondire a deux decimales
ic_vector <- round(ic_vector, digits=2)
return(ic_vector)
}
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
# datatable(ic_table)
# # export au format csv
date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
filename <- paste('ic', calcul, date, '.csv', sep = '_')
write.csv(ic_table, filename )
}
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
# datatable(ic_table)
# # export au format csv
# date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
# filename <- paste('ic', calcul, date, '.csv', sep = '_')
# write.csv(ic_table, filename )
return(ic_table)
}
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quartile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
# datatable(ic_table)
# # export au format csv
# date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
# filename <- paste('ic', calcul, date, '.csv', sep = '_')
# write.csv(ic_table, filename )
return(ic_table)
}
require(DT)
datatable(alsace)
alsace <- ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
ic_calculator <- function(param, calcul){
## création d'une table 1000x3 index vides
## pour initialiser les dimensions et la valeurs des cellules du dataframe qui suit
## création d'un DF initialisé avec les valeurs de c1 pour les cellules et le nombre de lignes.
humDF <- data.frame("lower_quantile"=c(0:999),"middl_quantile"=c(0:999),"upper_quantile"=c(0:999))*NA
## boucle qui calcule 1000 fois sur un échantillon de 50 tirages les centiles 25, 50 et 75 à partir du vecteur index (cf. infra)
## /!\ il faut exclure les NA du calcul de la moyenne également /!\
## /!\ j'ai renommé le centile_3 en centile_75 /!\
if(calcul=='quantile'){
for (i in 1:1000){
humDF$lower_quantile[i] <- quantile(sample(param,50,replace=T), 0.25, na.rm = T);
humDF$middl_quantile[i] <- quantile(sample(param,50,replace=T), 0.50, na.rm = T);
humDF$upper_quantile[i] <- quantile(sample(param,50,replace=T), 0.75, na.rm = T);
}
}else if (calcul=='decile'){
for (i in 1:1000){
humDF$lower_quantile[i]    <- quantile(sample(param,50,replace=T),0.1, na.rm = T);
humDF$middl_quantile[i]    <- mean(sample(param,50,replace=T), na.rm = T);
humDF$upper_quantile[i]    <- quantile(sample(param,50,replace=T),0.9, na.rm = T);
}
} else{
print('Aucune opération valide demandée')
}
moy_quant1 <- mean(humDF$lower_quantile) ## moyenne des 1000 1er quantiles
moy_quant2 <- mean(humDF$middl_quantile) ## moyenne des 1000 2eme quantiles
moy_quant3 <- mean(humDF$upper_quantile) ## moyenne des 1000 3eme quantiles
humDF_C25.sort=sort(humDF$lower_quantile)
humDF_C50.sort=sort(humDF$middl_quantile)
humDF_C75.sort=sort(humDF$upper_quantile)
length_C25.sort <- length(na.omit(humDF_C25.sort))
length_C50.sort <- length(na.omit(humDF_C50.sort))
length_C75.sort <- length(na.omit(humDF_C75.sort))
## c(humDF_C25.sort[25], humDF_C25.sort[975])
quant1_IC_bas <- humDF_C25.sort[25]
quant1_IC_haut <- humDF_C25.sort[975]
## c(humDF_C50.sort[25], humDF_C50.sort[975])
quant2_IC_bas <- humDF_C50.sort[25]
quant2_IC_haut <- humDF_C50.sort[975]
## c(humDF_C75.sort[25], humDF_C75.sort[975])
quant3_IC_bas <- humDF_C75.sort[25]
quant3_IC_haut <- humDF_C75.sort[975]
# La fonction retourne ce vecteur numeric contenant les
# trois moyennes et leur intervale de confiance
ic_vector = c(moy_quant1, quant1_IC_bas, quant1_IC_haut,
moy_quant2, quant2_IC_bas, quant2_IC_haut,
moy_quant3, quant3_IC_bas, quant3_IC_haut)
# arrondire a deux decimales
ic_vector <- round(ic_vector, digits=2)
return(ic_vector)
}
ic_table_maker <- function(reportingdf, randomdf, paramvector, calcul){
#liste vide a remplir
ic_table <- list()
# boucle de calcule implementant la fonction quantile
# avec filtrage par le vecteur vectornames sur le dataframe humdata
for (name in paramvector ){
# isolation de la colonne cible pour chaque iteration de la boucle
param_hum <- reportingdf[,name]
# affectation dans une variable intermediaire
result_hum <- ic_calculator(param_hum, calcul)
# isolation de la colonne cible pour chaque iteration de la boucle
param_dsk <- randomdf[,name]
# affectation dans une variable intermediaire
result_dsk <- ic_calculator(param_dsk, calcul)
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_reporting', sep='')]] <- result_hum
# insertion du vecteru numeric resultant dans la liste
ic_table[[paste(name,'_random', sep='')]] <- result_dsk
rm(list='param_hum','result_hum','param_dsk','result_dsk')
}
# transformation (cast) de la list en data.frame
ic_table <- as.data.frame(ic_table)
# transposition du tableau (data.frame)
ic_table <- as.data.frame(t(ic_table))
# Creation d’un vecteur de nom de colonne pour le tableau transpose
nom_de_colonne = c('moy_quant1', 'quant1_IC_bas', 'quant1_IC_haut',
'moy_quant2', 'quant2_IC_bas', 'quant2_IC_haut',
'moy_quant3', 'quant3_IC_bas', 'quant3_IC_haut')
# renommage des colonnes
colnames(ic_table) <- nom_de_colonne
# visualisation  de la table
# datatable(ic_table)
# # export au format csv
# date <- format(Sys.time(), "%A_%b_%d_%Hh%Mm%Ss_%Y")
# filename <- paste('ic', calcul, date, '.csv', sep = '_')
# write.csv(ic_table, filename )
return(ic_table)
}
alsace <- ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
datatable(alsace)
rhone_alpes_decile <- ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quantile')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='decile')
datatable(alsace_decile)
alsace_decile <- ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
datatable(alsace_decile)
datatable(idf_decile)
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quantile')
datatable(idf_decile)
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='que')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='e')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='dec')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quant')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quanti')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quantile')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quartile')
ic_calculator <- function(param, calcul){
## création d'une table 1000x3 index vides
## pour initialiser les dimensions et la valeurs des cellules du dataframe qui suit
## création d'un DF initialisé avec les valeurs de c1 pour les cellules et le nombre de lignes.
humDF <- data.frame("lower_quantile"=c(0:999),"middl_quantile"=c(0:999),"upper_quantile"=c(0:999))*NA
## boucle qui calcule 1000 fois sur un échantillon de 50 tirages les centiles 25, 50 et 75 à partir du vecteur index (cf. infra)
## /!\ il faut exclure les NA du calcul de la moyenne également /!\
## /!\ j'ai renommé le centile_3 en centile_75 /!\
if(calcul=='quartile'){
for (i in 1:1000){
humDF$lower_quantile[i] <- quantile(sample(param,50,replace=T), 0.25, na.rm = T);
humDF$middl_quantile[i] <- quantile(sample(param,50,replace=T), 0.50, na.rm = T);
humDF$upper_quantile[i] <- quantile(sample(param,50,replace=T), 0.75, na.rm = T);
}
}else if (calcul=='decile'){
for (i in 1:1000){
humDF$lower_quantile[i]    <- quantile(sample(param,50,replace=T),0.1, na.rm = T);
humDF$middl_quantile[i]    <- mean(sample(param,50,replace=T), na.rm = T);
humDF$upper_quantile[i]    <- quantile(sample(param,50,replace=T),0.9, na.rm = T);
}
} else{
print('Aucune opération valide demandée')
}
moy_quant1 <- mean(humDF$lower_quantile) ## moyenne des 1000 1er quantiles
moy_quant2 <- mean(humDF$middl_quantile) ## moyenne des 1000 2eme quantiles
moy_quant3 <- mean(humDF$upper_quantile) ## moyenne des 1000 3eme quantiles
humDF_C25.sort=sort(humDF$lower_quantile)
humDF_C50.sort=sort(humDF$middl_quantile)
humDF_C75.sort=sort(humDF$upper_quantile)
length_C25.sort <- length(na.omit(humDF_C25.sort))
length_C50.sort <- length(na.omit(humDF_C50.sort))
length_C75.sort <- length(na.omit(humDF_C75.sort))
## c(humDF_C25.sort[25], humDF_C25.sort[975])
quant1_IC_bas <- humDF_C25.sort[25]
quant1_IC_haut <- humDF_C25.sort[975]
## c(humDF_C50.sort[25], humDF_C50.sort[975])
quant2_IC_bas <- humDF_C50.sort[25]
quant2_IC_haut <- humDF_C50.sort[975]
## c(humDF_C75.sort[25], humDF_C75.sort[975])
quant3_IC_bas <- humDF_C75.sort[25]
quant3_IC_haut <- humDF_C75.sort[975]
# La fonction retourne ce vecteur numeric contenant les
# trois moyennes et leur intervale de confiance
ic_vector = c(moy_quant1, quant1_IC_bas, quant1_IC_haut,
moy_quant2, quant2_IC_bas, quant2_IC_haut,
moy_quant3, quant3_IC_bas, quant3_IC_haut)
# arrondire a deux decimales
ic_vector <- round(ic_vector, digits=2)
return(ic_vector)
}
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quantile')
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quartile')
france_quartile <- ic_table_maker(humdata, DSKdata, vectornames, calcul='quartile' )
datatable(france_quartile)
datatable(rhone_alpes_decile)
?datatable
datatable(rhone_alpes_decile, fillContainer = T)
datatable(france_quartile)
france_quartile <- ic_table_maker(humdata, DSKdata, vectornames, calcul='quartile' )
datatable(france_quartile)
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='quartile')
datatable(idf_decile)
alsace_decile <- ic_table_maker(humdata_al, DSKdata_al, vectornames, calcul='decile' )
datatable(alsace_decile)
rhone_alpes_decile <- ic_table_maker(humdata_ra, DSKdata_ra, vectornames, calcul='decile')
datatable(rhone_alpes_decile)
datatable(france_quartile)
datatable(idf_decile)
datatable(alsace_decile)
datatable(rhone_alpes_decile)
rm(quartile)
rm(list = c('vect', 'var', 'string'))
rm(list = c('foo'))
rm(list = c('date'))
datatable(rhone_alpes_decile)
require(DT)
datatable(rhone_alpes_decile)
humdata[humdata$date_piqure_saisie > c("2017-10-01","2018-10-01","2019-10-01") & humdata$date_piqure_saisie < c("2018-03-31","2019-03-31","2020-03-31"),]
dateobj <- humdata[humdata$date_piqure_saisie > c("2017-10-01","2018-10-01","2019-10-01") & humdata$date_piqure_saisie < c("2018-03-31","2019-03-31","2020-03-31"),]
View(dateobj)
dateobj_2 <-rbind(humdata_W17, humdata_W18, humdata_W19)
humdata_W17 <- subset(humdata, date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31")
humdata_W18 <- subset(humdata, date_piqure_saisie > "2018-10-01" & date_piqure_saisie  < "2019-03-31")
humdata_W19 <- subset(humdata, date_piqure_saisie > "2019-10-01" & date_piqure_saisie  < "2020-03-31")
dateobj_2 <-rbind(humdata_W17, humdata_W18, humdata_W19)
View(dateobj_2)
humdata_winter17 <- humdata[humdata$date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31",]
humdata_winter18 <- humdata[humdata$date_piqure_saisie > "2018-10-01" & date_piqure_saisie  < "2019-03-31",]
humdata_winter19 <- humdata[humdata$date_piqure_saisie > "2019-10-01" & date_piqure_saisie  < "2020-03-31",]
humdata_winter <-rbind(humdata_winter17, humdata_winter18, humdata_winter19)
humdata_winter17 <- humdata[humdata$date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31",]
humdata_winter17 <- humdata[humdata$date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31",]
View(humdata)
humdata_W17 <- subset(humdata, date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31")
humdata_winter17 <- humdata[humdata$date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31",]
humdata[humdata$date_piqure_saisie > "2017-10-01" & date_piqure_saisie  < "2018-03-31",]
humdata_winter17 <- humdata[humdata$date_piqure_saisie > "2017-10-01" & humdata$date_piqure_saisie  < "2018-03-31",]
humdata_winter18 <- humdata[humdata$date_piqure_saisie > "2018-10-01" & humdata$date_piqure_saisie  < "2019-03-31",]
humdata_winter19 <- humdata[humdata$date_piqure_saisie > "2019-10-01" & humdata$date_piqure_saisie  < "2020-03-31",]
humdata_winter <-rbind(humdata_winter17, humdata_winter18, humdata_winter19)
View(humdata_winter)
View(humdata_winter)
DSKdata_winter17 <- DSKdata[DSKdata$date_releve > "2017-10-01" & DSKdata$date_releve < "2018-03-31",]
DSKdata_winter18 <- DSKdata[DSKdata$date_releve > "2018-10-01" & DSKdata$date_releve < "2019-03-31",]
DSKdata_winter19 <- DSKdata[DSKdata$date_releve > "2019-10-01" & DSKdata$date_releve < "2020-03-31",]
DSKdata_winter <-rbind(DSKdata_winter17, DSKdata_winter18, DSKdata_winter19)
View(DSKdata_winter)
### 2.4.3. Sélection de la période hivernale "longue" (6 mois)
humdata_winter17 <- humdata[humdata$date_piqure_saisie => "2017-10-01" & humdata$date_piqure_saisie  <= "2018-03-31",]
humdata_winter18 <- humdata[humdata$date_piqure_saisie => "2018-10-01" & humdata$date_piqure_saisie  <= "2019-03-31",]
humdata_winter19 <- humdata[humdata$date_piqure_saisie => "2019-10-01" & humdata$date_piqure_saisie  <= "2020-03-31",]
humdata_winter <-rbind(humdata_winter17, humdata_winter18, humdata_winter19)
DSKdata_winter17 <- DSKdata[DSKdata$date_releve => "2017-10-01" & DSKdata$date_releve <= "2018-03-31",]
DSKdata_winter18 <- DSKdata[DSKdata$date_releve => "2018-10-01" & DSKdata$date_releve <= "2019-03-31",]
DSKdata_winter19 <- DSKdata[DSKdata$date_releve => "2019-10-01" & DSKdata$date_releve <= "2020-03-31",]
DSKdata_winter <-rbind(DSKdata_winter17, DSKdata_winter18, DSKdata_winter19)
humdata_winter17 <- humdata[humdata$date_piqure_saisie >= "2017-10-01" & humdata$date_piqure_saisie  <= "2018-03-31",]
humdata_winter18 <- humdata[humdata$date_piqure_saisie >= "2018-10-01" & humdata$date_piqure_saisie  <= "2019-03-31",]
humdata_winter19 <- humdata[humdata$date_piqure_saisie >= "2019-10-01" & humdata$date_piqure_saisie  <= "2020-03-31",]
humdata_winter <-rbind(humdata_winter17, humdata_winter18, humdata_winter19)
DSKdata_winter17 <- DSKdata[DSKdata$date_releve => "2017-10-01" & DSKdata$date_releve <= "2018-03-31",]
DSKdata_winter18 <- DSKdata[DSKdata$date_releve => "2018-10-01" & DSKdata$date_releve <= "2019-03-31",]
DSKdata_winter19 <- DSKdata[DSKdata$date_releve => "2019-10-01" & DSKdata$date_releve <= "2020-03-31",]
DSKdata_winter <-rbind(DSKdata_winter17, DSKdata_winter18, DSKdata_winter19)
View(DSKdata_winter)
DSKdata_winter17 <- DSKdata[DSKdata$date_releve >= "2017-10-01" & DSKdata$date_releve <= "2018-03-31",]
DSKdata_winter18 <- DSKdata[DSKdata$date_releve >= "2018-10-01" & DSKdata$date_releve <= "2019-03-31",]
DSKdata_winter19 <- DSKdata[DSKdata$date_releve >= "2019-10-01" & DSKdata$date_releve <= "2020-03-31",]
DSKdata_winter <-rbind(DSKdata_winter17, DSKdata_winter18, DSKdata_winter19)
View(DSKdata_winter)
View(humdata_winter)
humdata_winter17_short <- humdata[humdata$date_piqure_saisie >= "2017-11-01" & humdata$date_piqure_saisie  <= "2018-02-28",]
humdata_winter18_short <- humdata[humdata$date_piqure_saisie >= "2018-11-01" & humdata$date_piqure_saisie  <= "2019-02-28",]
humdata_winter19_short <- humdata[humdata$date_piqure_saisie >= "2019-11-01" & humdata$date_piqure_saisie  <= "2020-02-28",]
humdata_winter_short <-rbind(humdata_winter17, humdata_winter18, humdata_winter19)
DSKdata_winter17_short <- DSKdata[DSKdata$date_releve >= "2017-11-01" & DSKdata$date_releve <= "2018-02-28",]
DSKdata_winter18_short <- DSKdata[DSKdata$date_releve >= "2018-11-01" & DSKdata$date_releve <= "2019-02-28",]
DSKdata_winter19_short <- DSKdata[DSKdata$date_releve >= "2019-11-01" & DSKdata$date_releve <= "2020-02-28",]
DSKdata_winter_short <-rbind(DSKdata_winter17, DSKdata_winter18, DSKdata_winter19)
View(humdata_winter_short)
humdata_winter17 <- humdata[humdata$date_piqure_saisie >= "2017-10-01" & humdata$date_piqure_saisie  <= "2018-03-31",]
humdata_winter18 <- humdata[humdata$date_piqure_saisie >= "2018-10-01" & humdata$date_piqure_saisie  <= "2019-03-31",]
humdata_winter19 <- humdata[humdata$date_piqure_saisie >= "2019-10-01" & humdata$date_piqure_saisie  <= "2020-03-31",]
humdata_winter_long <-rbind(humdata_winter17, humdata_winter18, humdata_winter19)
DSKdata_winter17 <- DSKdata[DSKdata$date_releve >= "2017-10-01" & DSKdata$date_releve <= "2018-03-31",]
DSKdata_winter18 <- DSKdata[DSKdata$date_releve >= "2018-10-01" & DSKdata$date_releve <= "2019-03-31",]
DSKdata_winter19 <- DSKdata[DSKdata$date_releve >= "2019-10-01" & DSKdata$date_releve <= "2020-03-31",]
DSKdata_winter_long <-rbind(DSKdata_winter17, DSKdata_winter18, DSKdata_winter19)
### 2.4.3. Sélection de la période hivernale "longue" (6 mois)
humdata_winter17_long <- humdata[humdata$date_piqure_saisie >= "2017-10-01" & humdata$date_piqure_saisie  <= "2018-03-31",]
humdata_winter18_long <- humdata[humdata$date_piqure_saisie >= "2018-10-01" & humdata$date_piqure_saisie  <= "2019-03-31",]
humdata_winter19_long <- humdata[humdata$date_piqure_saisie >= "2019-10-01" & humdata$date_piqure_saisie  <= "2020-03-31",]
humdata_winter_long <-rbind(humdata_winter17_long, humdata_winter18_long, humdata_winter19_long)
DSKdata_winter17_long <- DSKdata[DSKdata$date_releve >= "2017-10-01" & DSKdata$date_releve <= "2018-03-31",]
DSKdata_winter18_long <- DSKdata[DSKdata$date_releve >= "2018-10-01" & DSKdata$date_releve <= "2019-03-31",]
DSKdata_winter19_long <- DSKdata[DSKdata$date_releve >= "2019-10-01" & DSKdata$date_releve <= "2020-03-31",]
DSKdata_winter_long <-rbind(DSKdata_winter17_long, DSKdata_winter18_long, DSKdata_winter19_long)
### 2.4.3. Sélection de la période hivernale "courte" (4 mois)
humdata_winter17_short <- humdata[humdata$date_piqure_saisie >= "2017-11-01" & humdata$date_piqure_saisie  <= "2018-02-28",]
humdata_winter18_short <- humdata[humdata$date_piqure_saisie >= "2018-11-01" & humdata$date_piqure_saisie  <= "2019-02-28",]
humdata_winter19_short <- humdata[humdata$date_piqure_saisie >= "2019-11-01" & humdata$date_piqure_saisie  <= "2020-02-28",]
humdata_winter_short <-rbind(humdata_winter17_short, humdata_winter18_short, humdata_winter19_short)
DSKdata_winter17_short <- DSKdata[DSKdata$date_releve >= "2017-11-01" & DSKdata$date_releve <= "2018-02-28",]
DSKdata_winter18_short <- DSKdata[DSKdata$date_releve >= "2018-11-01" & DSKdata$date_releve <= "2019-02-28",]
DSKdata_winter19_short <- DSKdata[DSKdata$date_releve >= "2019-11-01" & DSKdata$date_releve <= "2020-02-28",]
DSKdata_winter_short <-rbind(DSKdata_winter17_short, DSKdata_winter18_short, DSKdata_winter19_short)
# Periode hivernale longue
ic_hiver_long_decile <- ic_table_maker(humdata_winter_logn, DSKdata_winter_long, vectornames, calcule='decile')
# Periode hivernale longue
ic_hiver_long_decile <- ic_table_maker(humdata_winter_logn, DSKdata_winter_long, vectornames, calcul='decile')
# Periode hivernale longue
ic_hiver_long_decile <- ic_table_maker(humdata_winter_log, DSKdata_winter_long, vectornames, calcul='decile')
# Periode hivernale longue
ic_hiver_long_decile <- ic_table_maker(humdata_winter_long, DSKdata_winter_long, vectornames, calcul='decile')
datatale(ic_hiver_long_decile)
datatable(ic_hiver_long_decile)
ic_hiver_short_decile <- ic_table_maker(humdata_winter_short, DSKdata_wintershortg, vectornames, calcul='decile')
datatable(ic_hiver_short_decile)
# Periode hivernale longue
ic_hiver_short_decile <- ic_table_maker(humdata_winter_short, DSKdata_wintershortg, vectornames, calcul='decile')
# Periode hivernale longue
ic_hiver_short_decile <- ic_table_maker(humdata_winter_short, DSKdata_winter_short, vectornames, calcul='decile')
datatable(ic_hiver_short_decile)
# Periode hivernale longue quartiles
ic_hiver_long_decile <- ic_table_maker(humdata_winter_long, DSKdata_winter_long, vectornames, calcul='quartile')
datatable(ic_hiver_long_decile)
# Periode hivernale longue quartiles
ic_hiver_short_decile <- ic_table_maker(humdata_winter_short, DSKdata_winter_short, vectornames, calcul='quartile')
datatable(ic_hiver_short_decile)
BRt <- seq(from= -5, to= 30, by=2) ## tient compte des deux distributions
#### puis on fait l'histo en utilisant
### freq=F => des fréquences relatives et pas des effectifs
hist(DSKdata$temperature, breaks = BRt,
freq=F, # fréquences
col="grey",
main = "Average Temperatures for 42 Météo France Synoptic Stations \n and Dark Sky (France, july 2017 - february 2020), 995 days",
ylab = "Densities",
xlab = "Average Temperatures (T°C)"
)
View(humdata_winter_long)
View(humdata_winter17_short)
humdata_winter17_long <- humdata[humdata$date_piqure_saisie >= "2017-10-01" & humdata$date_piqure_saisie  <= "2018-03-31",]
humdata_winter18_long <- humdata[humdata$date_piqure_saisie >= "2018-10-01" & humdata$date_piqure_saisie  <= "2019-03-31",]
humdata_winter19_long <- humdata[humdata$date_piqure_saisie >= "2019-10-01" & humdata$date_piqure_saisie  <= "2020-03-31",]
humdata_winter_long <-rbind(humdata_winter17_long, humdata_winter18_long, humdata_winter19_long)
### 2.4.3. Sélection de la période hivernale "longue" (6 mois)
humdata_winter17_long <- humdata[humdata$date_piqure_saisie >= "2017-10-01" & humdata$date_piqure_saisie  <= "2018-03-31",]
humdata_winter18_long <- humdata[humdata$date_piqure_saisie >= "2018-10-01" & humdata$date_piqure_saisie  <= "2019-03-31",]
humdata_winter19_long <- humdata[humdata$date_piqure_saisie >= "2019-10-01" & humdata$date_piqure_saisie  <= "2020-03-31",]
humdata_winter_long <-rbind(humdata_winter17_long, humdata_winter18_long, humdata_winter19_long)
DSKdata_winter17_long <- DSKdata[DSKdata$date_releve >= "2017-10-01" & DSKdata$date_releve <= "2018-03-31",]
DSKdata_winter18_long <- DSKdata[DSKdata$date_releve >= "2018-10-01" & DSKdata$date_releve <= "2019-03-31",]
DSKdata_winter19_long <- DSKdata[DSKdata$date_releve >= "2019-10-01" & DSKdata$date_releve <= "2020-03-31",]
DSKdata_winter_long <-rbind(DSKdata_winter17_long, DSKdata_winter18_long, DSKdata_winter19_long)
### 2.4.3. Sélection de la période hivernale "courte" (4 mois)
humdata_winter17_short <- humdata[humdata$date_piqure_saisie >= "2017-11-01" & humdata$date_piqure_saisie  <= "2018-02-28",]
humdata_winter18_short <- humdata[humdata$date_piqure_saisie >= "2018-11-01" & humdata$date_piqure_saisie  <= "2019-02-28",]
humdata_winter19_short <- humdata[humdata$date_piqure_saisie >= "2019-11-01" & humdata$date_piqure_saisie  <= "2020-02-28",]
humdata_winter_short <-rbind(humdata_winter17_short, humdata_winter18_short, humdata_winter19_short)
DSKdata_winter17_short <- DSKdata[DSKdata$date_releve >= "2017-11-01" & DSKdata$date_releve <= "2018-02-28",]
DSKdata_winter18_short <- DSKdata[DSKdata$date_releve >= "2018-11-01" & DSKdata$date_releve <= "2019-02-28",]
DSKdata_winter19_short <- DSKdata[DSKdata$date_releve >= "2019-11-01" & DSKdata$date_releve <= "2020-02-28",]
DSKdata_winter_short <-rbind(DSKdata_winter17_short, DSKdata_winter18_short, DSKdata_winter19_short)
## 2.3 Methode d’importation depuis la BDD geographique PostgreSQL/PostGIS
## /!\ Ne pas commenter ni supprimer /!\
require(RPostgreSQL)
source("~/Developer/python/CNRS/projetCitique/pycitique/R/citik_humains/smartick_hum_meteo_BS.R")
datatable(france_quartile)
datatable(alsace_decile)
datatable(france_quartile)
require(DT)
datatable(france_quartile)
#idf
idf_decile <- ic_table_maker(humdata_idf, DSKdata_idf, vectornames, calcul='decile')
datatable(idf_decile)
?sample\
?sample
sample(humdata$temperature, 10, replace = T)
sample(humdata$temperature, 10, replace = T)
sample(humdata$temperature, 20, replace = T)
quartile(sample(humdata$temperature, 20, replace = T), .5)
quantile(sample(humdata$temperature, 20, replace = T), .5)
quantile(sample(humdata$temperature, 20, replace = T), .1)
quantile(sample(humdata$temperature, 20, replace = T), .01)
quantile(sample(humdata$temperature, 20, replace = T), .001)
quantile(sample(humdata$temperature, 20, replace = T), .00000001)
quantile(sample(humdata$temperature, 20, replace = T), .0001)
datatable(ic_hiver_short_decile)
